//! JS Glue Code Generator — produces JavaScript that loads WASM and provides the type bridge.
//!
//! The generated JS:
//! 1. Sets up TextEncoder/TextDecoder for string passing
//! 2. Maintains a handle map (integer → DOM Element) for safe cross-boundary references
//! 3. Provides `__volki_imports` with DOM binding implementations
//! 4. Has an async `init()` that fetches + instantiates the WASM module
//! 5. Registers per-function handlers and auto-binds `data-volki-on*` attributes

use crate::core::volkiwithstds::collections::{String, Vec};
use super::scanner::{RsxFunction, FnParam};
use crate::libs::web::wasm::types::{WasmAbi, rust_type_to_wasm};

/// Generate the complete JS glue file.
///
/// `client_fns` — only the Client-type functions from the scan.
/// `component_fns` — only the Component-type functions from the scan.
/// `source` — the full original source (for extracting function bodies to detect user externs).
/// `wasm_url` — the URL path where the `.wasm` file will be served (e.g., `/wasm/page_client.wasm`).
pub fn generate_js_glue(
    client_fns: &[&RsxFunction],
    component_fns: &[&RsxFunction],
    source: &str,
    wasm_url: &str,
    has_rsx_components: bool,
) -> String {
    let mut out = String::with_capacity(8192);

    let all_fns: Vec<&RsxFunction> = client_fns.iter().chain(component_fns.iter()).copied().collect();
    let has_components = !component_fns.is_empty();

    // Header
    out.push_str("// @generated by volki compiler — do not edit.\n");
    out.push_str("\"use strict\";\n\n");

    // TextEncoder / TextDecoder
    out.push_str("const __encoder = new TextEncoder();\n");
    out.push_str("const __decoder = new TextDecoder();\n\n");

    // Handle map for DOM elements
    out.push_str("let __handles = new Map();\n");
    out.push_str("let __next_handle = 1;\n\n");

    out.push_str("function __new_handle(el) {\n");
    out.push_str("  const id = __next_handle++;\n");
    out.push_str("  __handles.set(id, el);\n");
    out.push_str("  return id;\n");
    out.push_str("}\n\n");

    // WASM memory helpers
    out.push_str("let __wasm = null;\n\n");

    out.push_str("function __pass_string(s) {\n");
    out.push_str("  const bytes = __encoder.encode(s);\n");
    out.push_str("  const ptr = __wasm.exports.__volki_alloc(bytes.length);\n");
    out.push_str("  if (ptr === 0) throw new Error('volki: WASM alloc failed');\n");
    out.push_str("  new Uint8Array(__wasm.exports.memory.buffer, ptr, bytes.length).set(bytes);\n");
    out.push_str("  return [ptr, bytes.length];\n");
    out.push_str("}\n\n");

    out.push_str("function __read_string(ptr, len) {\n");
    out.push_str("  return __decoder.decode(new Uint8Array(__wasm.exports.memory.buffer, ptr, len));\n");
    out.push_str("}\n\n");

    // Component state infrastructure (emitted if any Component functions exist)
    if has_components {
        out.push_str("const __components = new Map();\n");
        out.push_str("let __current_component = null;\n");
        out.push_str("let __rerender_scheduled = false;\n");
        out.push_str("let __rerender_queue = new Set();\n\n");

        out.push_str("function __register_component(id, name, renderFn) {\n");
        out.push_str("  __components.set(id, { name, slots: [], renderFn, mounted: false });\n");
        out.push_str("}\n\n");

        out.push_str("function __schedule_rerender(comp_id) {\n");
        out.push_str("  __rerender_queue.add(comp_id);\n");
        out.push_str("  if (!__rerender_scheduled) {\n");
        out.push_str("    __rerender_scheduled = true;\n");
        out.push_str("    queueMicrotask(() => {\n");
        out.push_str("      __rerender_scheduled = false;\n");
        out.push_str("      const queue = [...__rerender_queue];\n");
        out.push_str("      __rerender_queue.clear();\n");
        out.push_str("      for (const id of queue) {\n");
        out.push_str("        const comp = __components.get(id);\n");
        out.push_str("        if (comp) {\n");
        out.push_str("          __wasm.exports.__volki_dealloc();\n");
        out.push_str("          __wasm.exports[comp.renderFn]();\n");
        out.push_str("          __run_effects(id);\n");
        out.push_str("        }\n");
        out.push_str("      }\n");
        out.push_str("    });\n");
        out.push_str("  }\n");
        out.push_str("}\n\n");

        out.push_str("function __run_effects(comp_id) {\n");
        out.push_str("  const comp = __components.get(comp_id);\n");
        out.push_str("  if (!comp || !comp.effects) return;\n");
        out.push_str("  for (let i = 0; i < comp.effects.length; i++) {\n");
        out.push_str("    const eff = comp.effects[i];\n");
        out.push_str("    if (!eff) continue;\n");
        out.push_str("    const depsChanged = !eff.prevDeps || eff.deps.some((d, j) => d !== eff.prevDeps[j]);\n");
        out.push_str("    if (depsChanged) {\n");
        out.push_str("      const cleanupFn = `__effect_cleanup_${comp.name}_${i}`;\n");
        out.push_str("      if (typeof __wasm.exports[cleanupFn] === 'function') {\n");
        out.push_str("        __wasm.exports.__volki_dealloc();\n");
        out.push_str("        __wasm.exports[cleanupFn]();\n");
        out.push_str("      }\n");
        out.push_str("      const effectFn = `__effect_${comp.name}_${i}`;\n");
        out.push_str("      if (typeof __wasm.exports[effectFn] === 'function') {\n");
        out.push_str("        __wasm.exports.__volki_dealloc();\n");
        out.push_str("        __wasm.exports[effectFn]();\n");
        out.push_str("      }\n");
        out.push_str("      eff.prevDeps = [...eff.deps];\n");
        out.push_str("    }\n");
        out.push_str("  }\n");
        out.push_str("}\n\n");
    }

    // Collect user externs from function bodies
    let mut user_extern_names: Vec<String> = Vec::new();
    for func in &all_fns {
        let body = &source[func.body_span.0..func.body_span.1];
        collect_user_extern_names(body, &mut user_extern_names);
    }

    // Detect which state imports are needed
    let mut needs_state_init_i32 = false;
    let mut needs_state_init_f32 = false;
    let mut needs_state_init_str = false;
    let mut needs_xstate_get_i32 = false;
    let mut needs_xstate_set_i32 = false;
    let mut needs_xstate_get_f32 = false;
    let mut needs_xstate_set_f32 = false;
    let mut needs_xstate_get_str = false;
    let mut needs_xstate_set_str = false;
    let mut needs_fmt_i32 = false;
    let mut needs_fmt_f32 = false;

    for func in &all_fns {
        let body = &source[func.body_span.0..func.body_span.1];
        if body.contains("use_state(") {
            if body.contains("use_state(\"") { needs_state_init_str = true; }
            if body.contains("_f32") { needs_state_init_f32 = true; }
            if !body.contains("_f32") && !body.contains("use_state(\"") || body.contains("_i32") || body.contains("true") || body.contains("false") {
                needs_state_init_i32 = true;
            }
        }
        if body.contains("state::get_i32(") { needs_xstate_get_i32 = true; }
        if body.contains("state::set_i32(") { needs_xstate_set_i32 = true; }
        if body.contains("state::get_f32(") { needs_xstate_get_f32 = true; }
        if body.contains("state::set_f32(") { needs_xstate_set_f32 = true; }
        if body.contains("state::get_str(") { needs_xstate_get_str = true; }
        if body.contains("state::set_str(") { needs_xstate_set_str = true; }
        if body.contains("state::fmt_i32(") { needs_fmt_i32 = true; }
        if body.contains("state::fmt_f32(") { needs_fmt_f32 = true; }
    }

    // Tuple use_state generates helper fns that rely on cross-component get/set imports,
    // even when source no longer contains explicit state::get_*/set_* calls.
    if has_components {
        needs_xstate_get_i32 = true;
        needs_xstate_set_i32 = true;
        needs_xstate_get_f32 = true;
        needs_xstate_set_f32 = true;
    }

    // Detect ref imports
    let mut needs_ref_init_i32 = false;
    let mut needs_ref_init_f32 = false;
    let mut needs_ref_init_el = false;
    let mut needs_ref_get_i32 = false;
    let mut needs_ref_set_i32 = false;
    let mut needs_ref_get_f32 = false;
    let mut needs_ref_set_f32 = false;
    for func in &all_fns {
        let body = &source[func.body_span.0..func.body_span.1];
        if body.contains("use_ref(") && !body.contains("use_ref_el(") {
            if body.contains("_i32") { needs_ref_init_i32 = true; }
            if body.contains("_f32") { needs_ref_init_f32 = true; }
            if !body.contains("_f32") { needs_ref_init_i32 = true; }
        }
        if body.contains("use_ref_el(") { needs_ref_init_el = true; }
        if body.contains("ref::get_i32(") { needs_ref_get_i32 = true; }
        if body.contains("ref::set_i32(") { needs_ref_set_i32 = true; }
        if body.contains("ref::get_f32(") { needs_ref_get_f32 = true; }
        if body.contains("ref::set_f32(") { needs_ref_set_f32 = true; }
    }

    // Detect effect imports
    let mut needs_effect = false;
    // Detect memo imports
    let mut needs_memo_i32 = false;
    let mut needs_memo_f32 = false;
    for func in &all_fns {
        let body = &source[func.body_span.0..func.body_span.1];
        if body.contains("use_effect(") { needs_effect = true; }
        if body.contains("use_memo_i32(") { needs_memo_i32 = true; }
        if body.contains("use_memo_f32(") { needs_memo_f32 = true; }
    }

    // Import object for WASM instantiation
    out.push_str("const __volki_imports = {\n");
    out.push_str("  env: {\n");

    // Component lifecycle imports
    if has_components {
        out.push_str("    __volki_component_begin(id) {\n");
        out.push_str("      __current_component = id;\n");
        out.push_str("    },\n");

        out.push_str("    __volki_component_end() {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (comp) comp.mounted = true;\n");
        out.push_str("      __current_component = null;\n");
        out.push_str("    },\n");
    }

    // State init imports
    if needs_state_init_i32 {
        out.push_str("    __volki_state_init_i32(slot, initial) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp) return initial;\n");
        out.push_str("      if (!comp.mounted) { comp.slots[slot] = initial; }\n");
        out.push_str("      return comp.slots[slot];\n");
        out.push_str("    },\n");
    }
    if needs_state_init_f32 {
        out.push_str("    __volki_state_init_f32(slot, initial) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp) return initial;\n");
        out.push_str("      if (!comp.mounted) { comp.slots[slot] = initial; }\n");
        out.push_str("      return comp.slots[slot];\n");
        out.push_str("    },\n");
    }
    if needs_state_init_str {
        out.push_str("    __volki_state_init_str(slot, ptr, len) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      const initial = __read_string(ptr, len);\n");
        out.push_str("      if (!comp) { const [p, _] = __pass_string(initial); return p; }\n");
        out.push_str("      if (!comp.mounted) { comp.slots[slot] = initial; }\n");
        out.push_str("      const val = comp.slots[slot];\n");
        out.push_str("      const [rp, _] = __pass_string(val);\n");
        out.push_str("      comp.__last_str_len = __encoder.encode(val).length;\n");
        out.push_str("      return rp;\n");
        out.push_str("    },\n");
        out.push_str("    __volki_state_init_str_len(slot) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp) return 0;\n");
        out.push_str("      return comp.__last_str_len || 0;\n");
        out.push_str("    },\n");
    }

    // Cross-function state access imports
    if needs_xstate_get_i32 {
        out.push_str("    __volki_xstate_get_i32(comp_id, slot) {\n");
        out.push_str("      const comp = __components.get(comp_id);\n");
        out.push_str("      return comp ? (comp.slots[slot] ?? 0) : 0;\n");
        out.push_str("    },\n");
    }
    if needs_xstate_set_i32 {
        out.push_str("    __volki_xstate_set_i32(comp_id, slot, value) {\n");
        out.push_str("      const comp = __components.get(comp_id);\n");
        out.push_str("      if (!comp) return;\n");
        out.push_str("      comp.slots[slot] = value;\n");
        out.push_str("      __schedule_rerender(comp_id);\n");
        out.push_str("    },\n");
    }
    if needs_xstate_get_f32 {
        out.push_str("    __volki_xstate_get_f32(comp_id, slot) {\n");
        out.push_str("      const comp = __components.get(comp_id);\n");
        out.push_str("      return comp ? (comp.slots[slot] ?? 0.0) : 0.0;\n");
        out.push_str("    },\n");
    }
    if needs_xstate_set_f32 {
        out.push_str("    __volki_xstate_set_f32(comp_id, slot, value) {\n");
        out.push_str("      const comp = __components.get(comp_id);\n");
        out.push_str("      if (!comp) return;\n");
        out.push_str("      comp.slots[slot] = value;\n");
        out.push_str("      __schedule_rerender(comp_id);\n");
        out.push_str("    },\n");
    }
    if needs_xstate_get_str {
        out.push_str("    __volki_xstate_get_str(comp_id, slot) {\n");
        out.push_str("      const comp = __components.get(comp_id);\n");
        out.push_str("      const val = comp ? (comp.slots[slot] ?? '') : '';\n");
        out.push_str("      const [ptr, _] = __pass_string(val);\n");
        out.push_str("      comp.__last_str_len = __encoder.encode(val).length;\n");
        out.push_str("      return ptr;\n");
        out.push_str("    },\n");
        out.push_str("    __volki_xstate_get_str_len(comp_id, slot) {\n");
        out.push_str("      const comp = __components.get(comp_id);\n");
        out.push_str("      if (!comp) return 0;\n");
        out.push_str("      return comp.__last_str_len || 0;\n");
        out.push_str("    },\n");
    }
    if needs_xstate_set_str {
        out.push_str("    __volki_xstate_set_str(comp_id, slot, ptr, len) {\n");
        out.push_str("      const comp = __components.get(comp_id);\n");
        out.push_str("      if (!comp) return;\n");
        out.push_str("      comp.slots[slot] = __read_string(ptr, len);\n");
        out.push_str("      __schedule_rerender(comp_id);\n");
        out.push_str("    },\n");
    }

    // Formatting imports
    if needs_fmt_i32 {
        out.push_str("    __volki_state_fmt_i32(value, buf_ptr, buf_len) {\n");
        out.push_str("      const s = String(value);\n");
        out.push_str("      const bytes = __encoder.encode(s);\n");
        out.push_str("      const len = Math.min(bytes.length, buf_len);\n");
        out.push_str("      new Uint8Array(__wasm.exports.memory.buffer, buf_ptr, len).set(bytes.subarray(0, len));\n");
        out.push_str("      return len;\n");
        out.push_str("    },\n");
    }
    if needs_fmt_f32 {
        out.push_str("    __volki_state_fmt_f32(value, buf_ptr, buf_len) {\n");
        out.push_str("      const s = String(value);\n");
        out.push_str("      const bytes = __encoder.encode(s);\n");
        out.push_str("      const len = Math.min(bytes.length, buf_len);\n");
        out.push_str("      new Uint8Array(__wasm.exports.memory.buffer, buf_ptr, len).set(bytes.subarray(0, len));\n");
        out.push_str("      return len;\n");
        out.push_str("    },\n");
    }

    // Ref imports
    if needs_ref_init_i32 {
        out.push_str("    __volki_ref_init_i32(slot, initial) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp) return initial;\n");
        out.push_str("      if (!comp.refs) comp.refs = [];\n");
        out.push_str("      if (!comp.mounted) { comp.refs[slot] = initial; }\n");
        out.push_str("      return comp.refs[slot];\n");
        out.push_str("    },\n");
    }
    if needs_ref_init_f32 {
        out.push_str("    __volki_ref_init_f32(slot, initial) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp) return initial;\n");
        out.push_str("      if (!comp.refs) comp.refs = [];\n");
        out.push_str("      if (!comp.mounted) { comp.refs[slot] = initial; }\n");
        out.push_str("      return comp.refs[slot];\n");
        out.push_str("    },\n");
    }
    if needs_ref_init_el {
        out.push_str("    __volki_ref_init_el(slot, sel_ptr, sel_len) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp) return 0;\n");
        out.push_str("      if (!comp.refs) comp.refs = [];\n");
        out.push_str("      if (!comp.mounted) {\n");
        out.push_str("        const sel = __read_string(sel_ptr, sel_len);\n");
        out.push_str("        const el = document.querySelector(sel);\n");
        out.push_str("        comp.refs[slot] = el ? __new_handle(el) : 0;\n");
        out.push_str("      }\n");
        out.push_str("      return comp.refs[slot];\n");
        out.push_str("    },\n");
    }
    if needs_ref_get_i32 {
        out.push_str("    __volki_ref_get_i32(slot) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp || !comp.refs) return 0;\n");
        out.push_str("      return comp.refs[slot] ?? 0;\n");
        out.push_str("    },\n");
    }
    if needs_ref_set_i32 {
        out.push_str("    __volki_ref_set_i32(slot, value) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp) return;\n");
        out.push_str("      if (!comp.refs) comp.refs = [];\n");
        out.push_str("      comp.refs[slot] = value;\n");
        out.push_str("    },\n");
    }
    if needs_ref_get_f32 {
        out.push_str("    __volki_ref_get_f32(slot) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp || !comp.refs) return 0.0;\n");
        out.push_str("      return comp.refs[slot] ?? 0.0;\n");
        out.push_str("    },\n");
    }
    if needs_ref_set_f32 {
        out.push_str("    __volki_ref_set_f32(slot, value) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp) return;\n");
        out.push_str("      if (!comp.refs) comp.refs = [];\n");
        out.push_str("      comp.refs[slot] = value;\n");
        out.push_str("    },\n");
    }

    // Effect imports
    if needs_effect {
        out.push_str("    __volki_effect_register(slot, dep_count) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp) return;\n");
        out.push_str("      if (!comp.effects) comp.effects = [];\n");
        out.push_str("      comp.effects[slot] = { deps: new Array(dep_count).fill(0), prevDeps: null, cleanup: null };\n");
        out.push_str("    },\n");
        out.push_str("    __volki_effect_set_dep(slot, dep_idx, value) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp || !comp.effects || !comp.effects[slot]) return;\n");
        out.push_str("      comp.effects[slot].deps[dep_idx] = value;\n");
        out.push_str("    },\n");
    }

    // Memo imports
    if needs_memo_i32 || needs_memo_f32 {
        out.push_str("    __volki_memo_begin(slot, dep_count) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp) return;\n");
        out.push_str("      if (!comp.memos) comp.memos = [];\n");
        out.push_str("      if (!comp.memos[slot]) comp.memos[slot] = { deps: new Array(dep_count).fill(0), prevDeps: null, value: 0 };\n");
        out.push_str("      comp.memos[slot].deps = new Array(dep_count).fill(0);\n");
        out.push_str("    },\n");
        out.push_str("    __volki_memo_set_dep(slot, dep_idx, value) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp || !comp.memos || !comp.memos[slot]) return;\n");
        out.push_str("      comp.memos[slot].deps[dep_idx] = value;\n");
        out.push_str("    },\n");
        out.push_str("    __volki_memo_changed(slot) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp || !comp.memos || !comp.memos[slot]) return 1;\n");
        out.push_str("      const m = comp.memos[slot];\n");
        out.push_str("      if (!m.prevDeps) return 1;\n");
        out.push_str("      return m.deps.some((d, i) => d !== m.prevDeps[i]) ? 1 : 0;\n");
        out.push_str("    },\n");
    }
    if needs_memo_i32 {
        out.push_str("    __volki_memo_store_i32(slot, value) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp || !comp.memos || !comp.memos[slot]) return;\n");
        out.push_str("      comp.memos[slot].value = value;\n");
        out.push_str("      comp.memos[slot].prevDeps = [...comp.memos[slot].deps];\n");
        out.push_str("    },\n");
        out.push_str("    __volki_memo_load_i32(slot) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp || !comp.memos || !comp.memos[slot]) return 0;\n");
        out.push_str("      return comp.memos[slot].value;\n");
        out.push_str("    },\n");
    }
    if needs_memo_f32 {
        out.push_str("    __volki_memo_store_f32(slot, value) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp || !comp.memos || !comp.memos[slot]) return;\n");
        out.push_str("      comp.memos[slot].value = value;\n");
        out.push_str("      comp.memos[slot].prevDeps = [...comp.memos[slot].deps];\n");
        out.push_str("    },\n");
        out.push_str("    __volki_memo_load_f32(slot) {\n");
        out.push_str("      const comp = __components.get(__current_component);\n");
        out.push_str("      if (!comp || !comp.memos || !comp.memos[slot]) return 0.0;\n");
        out.push_str("      return comp.memos[slot].value;\n");
        out.push_str("    },\n");
    }

    // DOM bindings
    generate_dom_import("__volki_dom_query", &all_fns, source, &mut out);
    generate_dom_import("__volki_dom_set_text", &all_fns, source, &mut out);
    generate_dom_import("__volki_dom_get_value", &all_fns, source, &mut out);
    generate_dom_import("__volki_dom_get_value_len", &all_fns, source, &mut out);
    generate_dom_import("__volki_dom_set_attr", &all_fns, source, &mut out);
    generate_dom_import("__volki_dom_add_class", &all_fns, source, &mut out);
    generate_dom_import("__volki_dom_remove_class", &all_fns, source, &mut out);
    generate_dom_import("__volki_console_log", &all_fns, source, &mut out);
    generate_dom_import("__volki_console_log_i32", &all_fns, source, &mut out);
    // New DOM operations
    generate_dom_import("__volki_dom_create", &all_fns, source, &mut out);
    generate_dom_import("__volki_dom_append", &all_fns, source, &mut out);
    generate_dom_import("__volki_dom_remove", &all_fns, source, &mut out);
    generate_dom_import("__volki_dom_set_html", &all_fns, source, &mut out);
    generate_dom_import("__volki_dom_toggle_class", &all_fns, source, &mut out);
    generate_dom_import("__volki_dom_get_attr", &all_fns, source, &mut out);
    generate_dom_import("__volki_dom_get_attr_len", &all_fns, source, &mut out);
    generate_dom_import("__volki_dom_remove_attr", &all_fns, source, &mut out);
    generate_dom_import("__volki_dom_query_all_count", &all_fns, source, &mut out);
    generate_dom_import("__volki_dom_query_all_get", &all_fns, source, &mut out);

    // RSX component externs
    if has_rsx_components {
        out.push_str("    __volki_dom_create_text(text_ptr, text_len) {\n");
        out.push_str("      const text = __read_string(text_ptr, text_len);\n");
        out.push_str("      const node = document.createTextNode(text);\n");
        out.push_str("      return __new_handle(node);\n");
        out.push_str("    },\n");

        out.push_str("    __volki_component_is_mounted(id) {\n");
        out.push_str("      const comp = __components.get(id);\n");
        out.push_str("      return (comp && comp.mounted) ? 1 : 0;\n");
        out.push_str("    },\n");

        out.push_str("    __volki_component_mount_point(id) {\n");
        out.push_str("      const comp = __components.get(id);\n");
        out.push_str("      if (!comp) return 0;\n");
        out.push_str("      const el = document.querySelector(`[data-volki-component=\"${comp.name}\"]`);\n");
        out.push_str("      return el ? __new_handle(el) : 0;\n");
        out.push_str("    },\n");
    }

    // User extern implementations (map to browser globals by name)
    for name in &user_extern_names {
        out.push_str("    ");
        out.push_str(name.as_str());
        out.push_str("(s_ptr, s_len) {\n");
        out.push_str("      const s = __read_string(s_ptr, s_len);\n");
        out.push_str("      window.");
        out.push_str(name.as_str());
        out.push_str("(s);\n");
        out.push_str("    },\n");
    }

    out.push_str("  }\n");
    out.push_str("};\n\n");

    out.push_str("const __volki_handlers = Object.create(null);\n\n");

    out.push_str("function __coerce_event_arg(event, paramType) {\n");
    out.push_str("  const target = event && event.target ? event.target : null;\n");
    out.push_str("  if (paramType === \"bool\") {\n");
    out.push_str("    return target && (\"checked\" in target) ? !!target.checked : false;\n");
    out.push_str("  }\n");
    out.push_str("  if (paramType === \"number\") {\n");
    out.push_str("    if (!target || !(\"value\" in target)) return 0;\n");
    out.push_str("    const n = Number(target.value);\n");
    out.push_str("    return Number.isFinite(n) ? n : 0;\n");
    out.push_str("  }\n");
    out.push_str("  if (paramType === \"string\") {\n");
    out.push_str("    return target && (\"value\" in target) ? String(target.value ?? \"\") : \"\";\n");
    out.push_str("  }\n");
    out.push_str("  return event;\n");
    out.push_str("}\n\n");

    out.push_str("function __bind_volki_handlers() {\n");
    out.push_str("  const all = document.querySelectorAll(\"*\");\n");
    out.push_str("  for (const el of all) {\n");
    out.push_str("    for (const attr of el.getAttributeNames()) {\n");
    out.push_str("      if (!attr.startsWith(\"data-volki-on\")) continue;\n");
    out.push_str("      const eventName = attr.slice(\"data-volki-on\".length);\n");
    out.push_str("      if (!eventName) continue;\n");
    out.push_str("      const handlerName = el.getAttribute(attr);\n");
    out.push_str("      const handler = handlerName ? __volki_handlers[handlerName] : null;\n");
    out.push_str("      if (!handler) {\n");
    out.push_str("        console.error(`volki: missing client handler '${handlerName}' for ${attr}`);\n");
    out.push_str("        continue;\n");
    out.push_str("      }\n");
    out.push_str("      if (handler.arity > 1) {\n");
    out.push_str("        console.error(`volki: handler '${handlerName}' has unsupported arity ${handler.arity}`);\n");
    out.push_str("        continue;\n");
    out.push_str("      }\n");
    out.push_str("      el.addEventListener(eventName, (event) => {\n");
    out.push_str("        if (eventName === \"click\" && el.tagName === \"A\") {\n");
    out.push_str("          event.preventDefault();\n");
    out.push_str("        }\n");
    out.push_str("        try {\n");
    out.push_str("          if (handler.arity === 0) {\n");
    out.push_str("            handler.call();\n");
    out.push_str("            return;\n");
    out.push_str("          }\n");
    out.push_str("          const kind = handler.paramTypes[0] || \"event\";\n");
    out.push_str("          handler.call(__coerce_event_arg(event, kind));\n");
    out.push_str("        } catch (e) {\n");
    out.push_str("          console.error(`volki: handler '${handlerName}' failed for event '${eventName}'`, e);\n");
    out.push_str("        }\n");
    out.push_str("      });\n");
    out.push_str("    }\n");
    out.push_str("  }\n");
    out.push_str("}\n\n");

    // Init function
    out.push_str("async function __volki_init() {\n");
    out.push_str("  const response = await fetch(\"");
    out.push_str(wasm_url);
    out.push_str("\");\n");
    out.push_str("  const bytes = await response.arrayBuffer();\n");
    out.push_str("  const result = await WebAssembly.instantiate(bytes, __volki_imports);\n");
    out.push_str("  __wasm = result.instance;\n");

    // Register and mount components
    for (i, func) in component_fns.iter().enumerate() {
        if let Some(name) = &func.name {
            let export_name = crate::vformat!("__volki_component_{}", name);
            out.push_str("  __register_component(");
            out.push_str(crate::vformat!("{}", i).as_str());
            out.push_str(", \"");
            out.push_str(name.as_str());
            out.push_str("\", \"");
            out.push_str(export_name.as_str());
            out.push_str("\");\n");
        }
    }

    // Initial render of all components
    if has_components {
        out.push_str("  __wasm.exports.__volki_dealloc();\n");
        for (i, func) in component_fns.iter().enumerate() {
            if let Some(name) = &func.name {
                out.push_str("  __wasm.exports.__volki_component_");
                out.push_str(name.as_str());
                out.push_str("();\n");
                out.push_str("  __run_effects(");
                out.push_str(crate::vformat!("{}", i).as_str());
                out.push_str(");\n");
            }
        }
    }

    out.push_str("  __bind_volki_handlers();\n");

    out.push_str("}\n\n");

    // Per-function handlers for DOM auto-binding
    out.push_str("// Client handler registry (used by data-volki-on* bindings)\n");

    for func in client_fns {
        let name = match &func.name {
            Some(n) => n.as_str(),
            None => continue,
        };
        // Skip __effect_* and __effect_cleanup_* functions — they're internal
        if name.starts_with("__effect_") {
            continue;
        }
        generate_js_handler(name, &func.params, &mut out);
    }

    // Auto-init on load
    out.push_str("__volki_init().catch(e => console.error('volki WASM init failed:', e));\n");

    out
}

/// Generate a single DOM binding implementation in the imports object.
fn generate_dom_import(
    name: &str,
    functions: &[&RsxFunction],
    source: &str,
    out: &mut String,
) {
    // Check if any function body references the pattern that requires this import
    let needed = match name {
        "__volki_dom_query" => functions.iter().any(|f| {
            let b = &source[f.body_span.0..f.body_span.1];
            b.contains("dom::query(") || b.contains("dom::query\"")
        }),
        "__volki_dom_set_text" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains(".set_text(")
        }),
        "__volki_dom_get_value" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains(".get_value(")
        }),
        "__volki_dom_get_value_len" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains(".get_value(")
        }),
        "__volki_dom_set_attr" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains(".set_attr(")
        }),
        "__volki_dom_add_class" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains(".add_class(")
        }),
        "__volki_dom_remove_class" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains(".remove_class(")
        }),
        "__volki_console_log" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains("dom::log")
        }),
        "__volki_console_log_i32" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains("dom::log")
        }),
        "__volki_dom_create" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains("dom::create(")
        }),
        "__volki_dom_append" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains("dom::append(")
        }),
        "__volki_dom_remove" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains("dom::remove(")
        }),
        "__volki_dom_set_html" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains("dom::set_html(")
        }),
        "__volki_dom_toggle_class" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains(".toggle_class(")
        }),
        "__volki_dom_get_attr" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains(".get_attr(")
        }),
        "__volki_dom_get_attr_len" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains(".get_attr(")
        }),
        "__volki_dom_remove_attr" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains(".remove_attr(")
        }),
        "__volki_dom_query_all_count" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains("dom::query_all_count(")
        }),
        "__volki_dom_query_all_get" => functions.iter().any(|f| {
            source[f.body_span.0..f.body_span.1].contains("dom::query_all_get(")
        }),
        _ => false,
    };

    if !needed { return; }

    match name {
        "__volki_dom_query" => {
            out.push_str("    __volki_dom_query(sel_ptr, sel_len) {\n");
            out.push_str("      const sel = __read_string(sel_ptr, sel_len);\n");
            out.push_str("      const el = document.querySelector(sel);\n");
            out.push_str("      return el ? __new_handle(el) : 0;\n");
            out.push_str("    },\n");
        }
        "__volki_dom_set_text" => {
            out.push_str("    __volki_dom_set_text(handle, text_ptr, text_len) {\n");
            out.push_str("      const el = __handles.get(handle);\n");
            out.push_str("      if (el) el.textContent = __read_string(text_ptr, text_len);\n");
            out.push_str("    },\n");
        }
        "__volki_dom_get_value" => {
            out.push_str("    __volki_dom_get_value(handle) {\n");
            out.push_str("      const el = __handles.get(handle);\n");
            out.push_str("      if (!el) return 0;\n");
            out.push_str("      const val = el.value || '';\n");
            out.push_str("      const [ptr, _] = __pass_string(val);\n");
            out.push_str("      return ptr;\n");
            out.push_str("    },\n");
        }
        "__volki_dom_get_value_len" => {
            out.push_str("    __volki_dom_get_value_len(handle) {\n");
            out.push_str("      const el = __handles.get(handle);\n");
            out.push_str("      if (!el) return 0;\n");
            out.push_str("      return __encoder.encode(el.value || '').length;\n");
            out.push_str("    },\n");
        }
        "__volki_dom_set_attr" => {
            out.push_str("    __volki_dom_set_attr(handle, name_ptr, name_len, val_ptr, val_len) {\n");
            out.push_str("      const el = __handles.get(handle);\n");
            out.push_str("      if (el) el.setAttribute(__read_string(name_ptr, name_len), __read_string(val_ptr, val_len));\n");
            out.push_str("    },\n");
        }
        "__volki_dom_add_class" => {
            out.push_str("    __volki_dom_add_class(handle, cls_ptr, cls_len) {\n");
            out.push_str("      const el = __handles.get(handle);\n");
            out.push_str("      if (el) el.classList.add(__read_string(cls_ptr, cls_len));\n");
            out.push_str("    },\n");
        }
        "__volki_dom_remove_class" => {
            out.push_str("    __volki_dom_remove_class(handle, cls_ptr, cls_len) {\n");
            out.push_str("      const el = __handles.get(handle);\n");
            out.push_str("      if (el) el.classList.remove(__read_string(cls_ptr, cls_len));\n");
            out.push_str("    },\n");
        }
        "__volki_console_log" => {
            out.push_str("    __volki_console_log(msg_ptr, msg_len) {\n");
            out.push_str("      console.log(__read_string(msg_ptr, msg_len));\n");
            out.push_str("    },\n");
        }
        "__volki_console_log_i32" => {
            out.push_str("    __volki_console_log_i32(value) {\n");
            out.push_str("      console.log(value);\n");
            out.push_str("    },\n");
        }
        "__volki_dom_create" => {
            out.push_str("    __volki_dom_create(tag_ptr, tag_len) {\n");
            out.push_str("      const tag = __read_string(tag_ptr, tag_len);\n");
            out.push_str("      const el = document.createElement(tag);\n");
            out.push_str("      return __new_handle(el);\n");
            out.push_str("    },\n");
        }
        "__volki_dom_append" => {
            out.push_str("    __volki_dom_append(parent, child) {\n");
            out.push_str("      const p = __handles.get(parent);\n");
            out.push_str("      const c = __handles.get(child);\n");
            out.push_str("      if (p && c) p.appendChild(c);\n");
            out.push_str("    },\n");
        }
        "__volki_dom_remove" => {
            out.push_str("    __volki_dom_remove(handle) {\n");
            out.push_str("      const el = __handles.get(handle);\n");
            out.push_str("      if (el && el.parentNode) el.parentNode.removeChild(el);\n");
            out.push_str("      __handles.delete(handle);\n");
            out.push_str("    },\n");
        }
        "__volki_dom_set_html" => {
            out.push_str("    __volki_dom_set_html(handle, html_ptr, html_len) {\n");
            out.push_str("      const el = __handles.get(handle);\n");
            out.push_str("      if (el) el.innerHTML = __read_string(html_ptr, html_len);\n");
            out.push_str("    },\n");
        }
        "__volki_dom_toggle_class" => {
            out.push_str("    __volki_dom_toggle_class(handle, cls_ptr, cls_len) {\n");
            out.push_str("      const el = __handles.get(handle);\n");
            out.push_str("      if (el) el.classList.toggle(__read_string(cls_ptr, cls_len));\n");
            out.push_str("    },\n");
        }
        "__volki_dom_get_attr" => {
            out.push_str("    __volki_dom_get_attr(handle, name_ptr, name_len) {\n");
            out.push_str("      const el = __handles.get(handle);\n");
            out.push_str("      if (!el) return 0;\n");
            out.push_str("      const val = el.getAttribute(__read_string(name_ptr, name_len)) || '';\n");
            out.push_str("      const [ptr, _] = __pass_string(val);\n");
            out.push_str("      return ptr;\n");
            out.push_str("    },\n");
        }
        "__volki_dom_get_attr_len" => {
            out.push_str("    __volki_dom_get_attr_len(handle, name_ptr, name_len) {\n");
            out.push_str("      const el = __handles.get(handle);\n");
            out.push_str("      if (!el) return 0;\n");
            out.push_str("      return __encoder.encode(el.getAttribute(__read_string(name_ptr, name_len)) || '').length;\n");
            out.push_str("    },\n");
        }
        "__volki_dom_remove_attr" => {
            out.push_str("    __volki_dom_remove_attr(handle, name_ptr, name_len) {\n");
            out.push_str("      const el = __handles.get(handle);\n");
            out.push_str("      if (el) el.removeAttribute(__read_string(name_ptr, name_len));\n");
            out.push_str("    },\n");
        }
        "__volki_dom_query_all_count" => {
            out.push_str("    __volki_dom_query_all_count(sel_ptr, sel_len) {\n");
            out.push_str("      const sel = __read_string(sel_ptr, sel_len);\n");
            out.push_str("      return document.querySelectorAll(sel).length;\n");
            out.push_str("    },\n");
        }
        "__volki_dom_query_all_get" => {
            out.push_str("    __volki_dom_query_all_get(sel_ptr, sel_len, idx) {\n");
            out.push_str("      const sel = __read_string(sel_ptr, sel_len);\n");
            out.push_str("      const els = document.querySelectorAll(sel);\n");
            out.push_str("      if (idx < 0 || idx >= els.length) return 0;\n");
            out.push_str("      return __new_handle(els[idx]);\n");
            out.push_str("    },\n");
        }
        _ => {}
    }
}

/// Generate a JS wrapper function that handles type conversion and calls the WASM export.
fn js_param_kind(ty: &str) -> &'static str {
    if ty == "bool" {
        "bool"
    } else if ty == "&str" || ty == "str" || ty == "String" {
        "string"
    } else if ty.contains("i32") || ty.contains("i64") || ty.contains("u32") || ty.contains("u64")
        || ty.contains("f32") || ty.contains("f64")
    {
        "number"
    } else {
        "event"
    }
}

fn generate_js_handler(name: &str, params: &[FnParam], out: &mut String) {
    out.push_str("__volki_handlers[\"");
    out.push_str(name);
    out.push_str("\"] = {\n");
    out.push_str("  arity: ");
    out.push_str(crate::vformat!("{}", params.len()).as_str());
    out.push_str(",\n");
    out.push_str("  paramTypes: [");
    for (i, p) in params.iter().enumerate() {
        if i > 0 {
            out.push_str(", ");
        }
        out.push('"');
        out.push_str(js_param_kind(p.ty.as_str()));
        out.push('"');
    }
    out.push_str("],\n");
    out.push_str("  call: function(");

    // JS parameter list (high-level types)
    let mut first = true;
    for param in params {
        if !first { out.push_str(", "); }
        first = false;
        out.push_str(param.name.as_str());
    }
    out.push_str(") {\n");

    // Reset allocator before each call
    out.push_str("  __wasm.exports.__volki_dealloc();\n");

    // Convert params and build WASM call arguments
    let mut wasm_args: Vec<String> = Vec::new();

    for param in params {
        let abi = rust_type_to_wasm(param.ty.as_str());
        match abi {
            WasmAbi::StringPair => {
                let ptr_var = crate::vformat!("__{}_p", param.name);
                out.push_str("  const [");
                out.push_str(ptr_var.as_str());
                out.push_str(", __");
                out.push_str(param.name.as_str());
                out.push_str("_l] = __pass_string(");
                out.push_str(param.name.as_str());
                out.push_str(");\n");
                wasm_args.push(ptr_var);
                wasm_args.push(crate::vformat!("__{}_l", param.name));
            }
            WasmAbi::Direct(_) => {
                let arg = if param.ty.as_str() == "bool" {
                    crate::vformat!("({} ? 1 : 0)", param.name)
                } else {
                    param.name.clone()
                };
                wasm_args.push(arg);
            }
            WasmAbi::Void => {}
        }
    }

    // Call WASM export
    out.push_str("  __wasm.exports.");
    out.push_str(name);
    out.push('(');
    for (i, arg) in wasm_args.iter().enumerate() {
        if i > 0 { out.push_str(", "); }
        out.push_str(arg.as_str());
    }
    out.push_str(");\n");

    out.push_str("  }\n");
    out.push_str("};\n\n");
}

/// Collect extern function names from user-declared `extern "C"` blocks.
fn collect_user_extern_names(body: &str, names: &mut Vec<String>) {
    let mut search_from = 0;
    while let Some(idx) = body[search_from..].find("extern \"C\"") {
        let abs_idx = search_from + idx;
        if let Some(brace_start) = body[abs_idx..].find('{') {
            let brace_abs = abs_idx + brace_start;
            if let Some(brace_end) = body[brace_abs..].find('}') {
                let inner = &body[brace_abs + 1..brace_abs + brace_end];
                for line in inner.lines() {
                    let trimmed = line.trim();
                    if trimmed.starts_with("fn ") {
                        // Extract function name: "fn alert(s_ptr: i32, s_len: i32);" → "alert"
                        let after_fn = &trimmed[3..];
                        if let Some(paren) = after_fn.find('(') {
                            let fname = after_fn[..paren].trim();
                            if !fname.is_empty() {
                                // Deduplicate
                                let already = names.iter().any(|n| n.as_str() == fname);
                                if !already {
                                    names.push(String::from(fname));
                                }
                            }
                        }
                    }
                }
                search_from = brace_abs + brace_end + 1;
                continue;
            }
        }
        break;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::libs::web::compiler::scanner;
    use crate::libs::web::compiler::scanner::RsxReturnType;

    fn empty_components() -> Vec<&'static RsxFunction> {
        Vec::new()
    }

    #[test]
    fn test_generate_js_glue_basic() {
        let source = r#"
pub fn on_click(target: &str) -> Client {
    let el = dom::query(target);
    el.set_text("Clicked!");
}
"#;
        let fns = scanner::scan_functions(source);
        let client_fns: Vec<&RsxFunction> = fns.iter()
            .filter(|f| f.return_type == RsxReturnType::Client)
            .collect();

        let js = generate_js_glue(&client_fns, &empty_components(), source, "/wasm/page_client.wasm", false);

        assert!(js.contains("const __encoder = new TextEncoder()"));
        assert!(js.contains("const __decoder = new TextDecoder()"));
        assert!(js.contains("__volki_dom_query(sel_ptr, sel_len)"));
        assert!(js.contains("__volki_dom_set_text(handle, text_ptr, text_len)"));
        assert!(js.contains("__volki_handlers[\"on_click\"]"));
        assert!(js.contains("call: function(target)"));
        assert!(js.contains("__pass_string(target)"));
        assert!(js.contains("fetch(\"/wasm/page_client.wasm\")"));
        assert!(js.contains("__volki_init()"));
    }

    #[test]
    fn test_generate_js_glue_no_params() {
        let source = r#"
pub fn init() -> Client {
    dom::log("ready");
}
"#;
        let fns = scanner::scan_functions(source);
        let client_fns: Vec<&RsxFunction> = fns.iter()
            .filter(|f| f.return_type == RsxReturnType::Client)
            .collect();

        let js = generate_js_glue(&client_fns, &empty_components(), source, "/wasm/init.wasm", false);
        assert!(js.contains("__volki_handlers[\"init\"]"));
        assert!(js.contains("__volki_console_log(msg_ptr, msg_len)"));
    }

    #[test]
    fn test_generate_js_glue_mixed_params() {
        let source = r#"
pub fn update(id: i32, text: &str, flag: bool) -> Client {
    dom::log(text);
}
"#;
        let fns = scanner::scan_functions(source);
        let client_fns: Vec<&RsxFunction> = fns.iter()
            .filter(|f| f.return_type == RsxReturnType::Client)
            .collect();

        let js = generate_js_glue(&client_fns, &empty_components(), source, "/wasm/x.wasm", false);
        assert!(js.contains("__volki_handlers[\"update\"]"));
        assert!(js.contains("call: function(id, text, flag)"));
        assert!(js.contains("(flag ? 1 : 0)"));
    }

    #[test]
    fn test_generate_js_only_needed_imports() {
        let source = r#"
pub fn log_it() -> Client {
    dom::log("hello");
}
"#;
        let fns = scanner::scan_functions(source);
        let client_fns: Vec<&RsxFunction> = fns.iter()
            .filter(|f| f.return_type == RsxReturnType::Client)
            .collect();

        let js = generate_js_glue(&client_fns, &empty_components(), source, "/wasm/x.wasm", false);
        assert!(js.contains("__volki_console_log("));
        assert!(!js.contains("__volki_dom_query("));
        assert!(!js.contains("__volki_dom_set_text("));
    }

    #[test]
    fn test_user_extern_js_mapping() {
        let source = r#"
pub fn show_alert(msg: &str) -> Client {
    extern "C" {
        fn alert(s_ptr: i32, s_len: i32);
    }
    unsafe { alert(msg.as_ptr() as i32, msg.len() as i32); }
}
"#;
        let fns = scanner::scan_functions(source);
        let client_fns: Vec<&RsxFunction> = fns.iter()
            .filter(|f| f.return_type == RsxReturnType::Client)
            .collect();

        let js = generate_js_glue(&client_fns, &empty_components(), source, "/wasm/x.wasm", false);
        assert!(js.contains("alert(s_ptr, s_len)"));
        assert!(js.contains("window.alert(s)"));
    }

    // ── Component tests ──

    #[test]
    fn test_generate_js_component_infrastructure() {
        let source = r##"
pub fn counter() -> Component {
    let count = use_state(0_i32);
    let el = dom::query("#count");
    el.set_text(state::fmt_i32(count));
}
"##;
        let fns = scanner::scan_functions(source);
        let component_fns: Vec<&RsxFunction> = fns.iter()
            .filter(|f| f.return_type == RsxReturnType::Component)
            .collect();

        let js = generate_js_glue(&Vec::new(), &component_fns, source, "/wasm/page_client.wasm", false);

        // Component state infrastructure
        assert!(js.contains("const __components = new Map()"));
        assert!(js.contains("let __current_component = null"));
        assert!(js.contains("function __register_component("));
        assert!(js.contains("function __schedule_rerender("));
        assert!(js.contains("queueMicrotask("));

        // State imports
        assert!(js.contains("__volki_component_begin(id)"));
        assert!(js.contains("__volki_component_end()"));
        assert!(js.contains("__volki_state_init_i32(slot, initial)"));
        assert!(js.contains("__volki_state_fmt_i32(value, buf_ptr, buf_len)"));

        // Component registration in init
        assert!(js.contains("__register_component(0, \"counter\", \"__volki_component_counter\")"));
        // Initial render
        assert!(js.contains("__wasm.exports.__volki_component_counter()"));
    }

    #[test]
    fn test_generate_js_component_with_client() {
        let source = r##"
pub fn counter() -> Component {
    let count = use_state(0_i32);
    let el = dom::query("#count");
    el.set_text(state::fmt_i32(count));
}

pub fn on_increment() -> Client {
    let count = state::get_i32("counter", 0);
    state::set_i32("counter", 0, count + 1);
}
"##;
        let fns = scanner::scan_functions(source);
        let client_fns: Vec<&RsxFunction> = fns.iter()
            .filter(|f| f.return_type == RsxReturnType::Client)
            .collect();
        let component_fns: Vec<&RsxFunction> = fns.iter()
            .filter(|f| f.return_type == RsxReturnType::Component)
            .collect();

        let js = generate_js_glue(&client_fns, &component_fns, source, "/wasm/page_client.wasm", false);

        // Cross-function state access
        assert!(js.contains("__volki_xstate_get_i32(comp_id, slot)"));
        assert!(js.contains("__volki_xstate_set_i32(comp_id, slot, value)"));
        assert!(js.contains("__schedule_rerender(comp_id)"));

        // Client handler
        assert!(js.contains("__volki_handlers[\"on_increment\"]"));
    }

    #[test]
    fn test_generate_js_no_components_no_state_infra() {
        let source = r#"
pub fn on_click() -> Client {
    dom::log("clicked");
}
"#;
        let fns = scanner::scan_functions(source);
        let client_fns: Vec<&RsxFunction> = fns.iter()
            .filter(|f| f.return_type == RsxReturnType::Client)
            .collect();

        let js = generate_js_glue(&client_fns, &empty_components(), source, "/wasm/x.wasm", false);

        // No component infrastructure
        assert!(!js.contains("__components"));
        assert!(!js.contains("__current_component"));
        assert!(!js.contains("__register_component"));
        assert!(!js.contains("__schedule_rerender"));
    }
}
