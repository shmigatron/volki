//! Hooks API — marker declarations for reactive primitives in `-> Component` functions.
//!
//! This module provides phantom function signatures that the compiler recognizes
//! and transforms into WASM extern calls. It mirrors the pattern used by `dom.rs`
//! and `state.rs`.
//!
//! # Phase 1 (implemented)
//!
//! ```rust,ignore
//! pub fn counter() -> Component {
//!     let count = use_state(0_i32);   // slot 0, returns current i32 value
//!     let active = use_state(false);  // slot 1, bool → i32
//! }
//! ```
//!
//! # Phase 2 (declared, not yet functional)
//!
//! ```rust,ignore
//! pub fn dashboard() -> Component {
//!     use_effect(&[count]);  // re-run side-effect when deps change
//! }
//! ```
//!
//! # Phase 3 (declared, not yet functional)
//!
//! ```rust,ignore
//! pub fn dashboard() -> Component {
//!     let doubled = use_memo(&[count], count * 2);  // cached derived value
//! }
//! ```

/// Phase 1: Initialize a state slot in a Component. Returns the current value.
///
/// The compiler infers the WASM type from the argument suffix:
/// - `0_i32` → `__volki_state_init_i32(slot, 0)`
/// - `0.0_f32` → `__volki_state_init_f32(slot, 0.0)`
/// - `true`/`false` → `__volki_state_init_i32(slot, 1/0)`
pub fn use_state<T>(_initial: T) -> T { _initial }

/// Phase 1: Register an effect slot with dependencies.
///
/// The effect body is defined in a companion function named `__effect_{component}_{slot}`.
/// An optional cleanup function `__effect_cleanup_{component}_{slot}` is called before re-running.
///
/// ```rust,ignore
/// pub fn counter() -> Component {
///     let count = use_state(0_i32);
///     use_effect(&[count]);       // registers effect slot 0 with deps
/// }
///
/// pub fn __effect_counter_0() -> Client {
///     dom::log("count changed!");
/// }
/// ```
pub fn use_effect(_deps: &[i32]) {}

/// Phase 1: Initialize a mutable ref slot. Does NOT trigger rerender on set.
///
/// The compiler infers the WASM type from the argument suffix (same as use_state).
pub fn use_ref<T>(_initial: T) -> T { _initial }

/// Phase 1: Initialize a ref slot with a cached DOM element handle.
///
/// Queries the DOM once on first mount, caches the handle in the ref slot.
pub fn use_ref_el(_selector: &str) -> i32 { 0 }

/// Phase 1: Memoize a derived i32 value based on dependencies.
///
/// ```rust,ignore
/// let sum = use_memo_i32(a + b, &[a, b]);
/// ```
pub fn use_memo_i32(expr: i32, _deps: &[i32]) -> i32 { expr }

/// Phase 1: Memoize a derived f32 value based on dependencies.
///
/// ```rust,ignore
/// let ratio = use_memo_f32(a / b, &[a, b]);
/// ```
pub fn use_memo_f32(expr: f32, _deps: &[i32]) -> f32 { expr }

/// Which implementation phase a hook belongs to.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HookPhase {
    /// Implemented and code-generated by the compiler.
    Phase1,
    /// Declared but not yet functional in the compiler.
    Phase2,
    /// Declared but not yet functional in the compiler.
    Phase3,
}

/// The set of hook API patterns the compiler recognizes and their extern mappings.
///
/// Each entry: `(source_pattern, extern_fn_name, phase)`
pub const HOOKS_API_MAP: &[(&str, &str, HookPhase)] = &[
    ("use_state(",    "__volki_state_init",      HookPhase::Phase1),
    ("use_ref(",      "__volki_ref_init",        HookPhase::Phase1),
    ("use_ref_el(",   "__volki_ref_init_el",     HookPhase::Phase1),
    ("use_effect(",    "__volki_effect_register",  HookPhase::Phase1),
    ("use_memo_i32(",  "__volki_memo_i32",        HookPhase::Phase1),
    ("use_memo_f32(",  "__volki_memo_f32",        HookPhase::Phase1),
];

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hooks_api_map_has_all_entries() {
        assert_eq!(HOOKS_API_MAP.len(), 6);
    }

    #[test]
    fn test_hooks_api_map_use_state() {
        let (pattern, extern_name, phase) = HOOKS_API_MAP[0];
        assert_eq!(pattern, "use_state(");
        assert_eq!(extern_name, "__volki_state_init");
        assert_eq!(phase, HookPhase::Phase1);
    }

    #[test]
    fn test_hooks_api_map_use_ref() {
        let (pattern, extern_name, phase) = HOOKS_API_MAP[1];
        assert_eq!(pattern, "use_ref(");
        assert_eq!(extern_name, "__volki_ref_init");
        assert_eq!(phase, HookPhase::Phase1);
    }

    #[test]
    fn test_hooks_api_map_use_ref_el() {
        let (pattern, extern_name, phase) = HOOKS_API_MAP[2];
        assert_eq!(pattern, "use_ref_el(");
        assert_eq!(extern_name, "__volki_ref_init_el");
        assert_eq!(phase, HookPhase::Phase1);
    }

    #[test]
    fn test_hooks_api_map_use_effect() {
        let (pattern, extern_name, phase) = HOOKS_API_MAP[3];
        assert_eq!(pattern, "use_effect(");
        assert_eq!(extern_name, "__volki_effect_register");
        assert_eq!(phase, HookPhase::Phase1);
    }

    #[test]
    fn test_hooks_api_map_use_memo_i32() {
        let (pattern, extern_name, phase) = HOOKS_API_MAP[4];
        assert_eq!(pattern, "use_memo_i32(");
        assert_eq!(extern_name, "__volki_memo_i32");
        assert_eq!(phase, HookPhase::Phase1);
    }

    #[test]
    fn test_hooks_api_map_use_memo_f32() {
        let (pattern, extern_name, phase) = HOOKS_API_MAP[5];
        assert_eq!(pattern, "use_memo_f32(");
        assert_eq!(extern_name, "__volki_memo_f32");
        assert_eq!(phase, HookPhase::Phase1);
    }

    #[test]
    fn test_use_state_returns_initial() {
        assert_eq!(use_state(42_i32), 42);
        assert_eq!(use_state(true), true);
    }

    #[test]
    fn test_use_memo_returns_expr() {
        assert_eq!(use_memo_i32(100, &[]), 100);
        assert_eq!(use_memo_f32(3.14, &[]), 3.14);
    }

    #[test]
    fn test_phase_enum_values() {
        assert_ne!(HookPhase::Phase1, HookPhase::Phase2);
        assert_ne!(HookPhase::Phase2, HookPhase::Phase3);
        assert_ne!(HookPhase::Phase1, HookPhase::Phase3);
    }
}
